from typing import Any, Optional, List, Generic, Iterable, Tuple, Generic, TypeVar, Mapping, Iterator

from .bond import Bond
from .molecule import Molecule
from ..core.settings import Settings

T1 = TypeVar('T1', bound=float)
T2 = TypeVar('T2', bound=float)
T3 = TypeVar('T3', bound=float)

Matrix = Tuple[Tuple[float, float, float],
               Tuple[float, float, float],
               Tuple[float, float, float]]

class Atom(Iterable[float], Generic[T1, T2, T3]):
    symbol: str = ...
    atnum: int = ...
    mol: Molecule = ...
    bonds: List[Bond] = ...
    properties: Settings = ...
    coords: Tuple[T1, T2, T3] = ...

    def __init__(self, atnum: int = ..., symbol: Optional[str] = ..., coords: Optional[Tuple[T1, T2, T3]] = ..., unit: str = ..., bonds: Optional[List[Bond]] = ..., mol: Optional[Molecule] = ..., **other: Any) -> None: ...
    def __iter__(self) -> Iterator[float]: ...

    x: T1 = ...
    y: T2 = ...
    z: T3 = ...
    mass: float = ...
    radius: float = ...
    connectors: float = ...
    is_metallic: bool = ...
    is_electronegative: bool = ...

    def translate(self, vector: Iterable[float], unit: str = ...) -> None: ...
    def move_to(self, point: Iterable[float], unit: str = ...) -> None: ...
    def distance_to(self, point: Iterable[float], unit: str = ..., result_unit: str = ...) -> Tuple[float, float, float]: ...
    def vector_to(self, point: Iterable[float], unit: str = ..., result_unit: str = ...) -> float: ...
    def angle(self, point1: Iterable[float], point2: Iterable[float], point1unit: str = ..., point2unit: str = ..., result_unit: str = ...): ...
    def rotate(self, matrix: Union[np.array, Matrix]) -> None: ...
    def neighbors(self) -> List[Atom]: ...

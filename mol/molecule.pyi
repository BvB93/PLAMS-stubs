import sys
from os import PathLike
from abc import abstractmethod
from typing import (
    Sized,
    List,
    Any,
    Union,
    Iterable,
    Optional,
    Generic,
    TypeVar,
    Collection,
    Sequence,
    Tuple,
    Dict,
    Callable,
    TextIO,
    Iterator,
    overload
)

import numpy as np

from .atom import Atom
from .bond import Bond
from .pdbtools import PDBHandler
from ..settings import Settings

if sys.version_info >= (3, 8):
    from typing import Literal, SupportsIndex, TypedDict
else:
    from typing_extensions import Literal, Protocol, TypedDict

    class SupportsIndex(Protocol):
        """An ABC with one abstract method __index__."""
        @abstractmethod
        def __index__(self) -> int:
            pass


AT = TypeVar('AT', bound=Atom)
BT = TypeVar('BT', bound=Bond)

Vector = Tuple[float, float, float]
Matrix = Tuple[Vector, Vector, Vector]


class AtomDict(TypedDict):
    atnum: int
    bonds: List[int]
    coords: Tuple[float, float, float]
    properties: Settings


class BondDict(TypedDict):
    atom1: int
    atom2: int
    order: float
    properties: Settings


class _MolDict(TypedDict, total=False):
    charge: int


class MolDict(_MolDict):
    atoms: List[AtomDict]
    bonds: List[BondDict]
    lattice: List[Vector]
    properties: Settings


class Molecule(Sized, Iterable[Atom], Generic[AT, BT]):
    atoms: List[AT] = ...
    bonds: List[BT] = ...
    lattice: List[Vector] = ...
    properties: Settings = ...

    def __init__(self, filename: Union[None, str, PathLike] = ..., inputformat: Optional[str] = ..., **other: Any) -> None: ...
    def copy(self, atoms: Optional[Collection[AT]] = ...) -> Molecule: ...
    def add_molecule(self, other: Molecule, copy: bool = ...) -> None: ...
    def add_atom(self, atom: AT, adjacent: Optional[Iterable[AT]] = ...) -> None: ...
    def delete_atom(self, atom: AT) -> None: ...
    @overload
    def add_bond(self, arg1: AT, arg2: AT = ..., order: float = ...) -> None: ...
    @overload
    def add_bond(self, arg1: BT, arg2: Any = ..., order: float = ...) -> None: ...
    @overload
    def delete_bond(self, arg1: AT, arg2: AT = ...) -> None: ...
    @overload
    def delete_bond(self, arg1: BT, arg2: Any = ...) -> None: ...
    def delete_all_bonds(self) -> None: ...
    def find_bond(self, atom1: AT, atom2: AT): ...
    def set_atoms_id(self, start: int = ...) -> None: ...
    def unset_atoms_id(self) -> None: ...
    def neighbors(self, atom: AT) -> List[AT]: ...
    def bond_matrix(self) -> np.ndarray: ...
    def separate(self) -> List[Molecule]: ...
    def guess_bonds(self, atom_subset: Optional[Sequence[AT]] = ..., dmax: float = ...) -> None: ...
    def in_ring(self, arg: Union[AT, BT]) -> bool: ...
    def supercell(self, *args: Vector) -> List[Vector]: ...
    def unit_cell_volume(self, unit: str = ...) -> float: ...
    def set_integer_bonds(self, action: str = ..., tolerance: float = ...) -> None: ...
    @overload
    def index(self, value: AT, start: int = ..., stop: Optional[int] = ...) -> int: ...
    @overload
    def index(self, value: BT, start: int = ..., stop: Optional[int] = ...) -> Tuple[int, int]: ...
    @overload
    def round_coords(self, decimals: int = ..., inplace: Literal[False] = ...) -> Molecule: ...
    @overload
    def round_coords(self, decimals: int = ..., inplace: Literal[True] = ...) -> None: ...
    def translate(self, vector: Tuple[float, float, float], unit: str = ...) -> None: ...
    def rotate_lattice(self, matrix: Matrix) -> None: ...
    def rotate(self, matrix: Matrix, lattice: bool = ...) -> None: ...
    def align_lattice(self, convention: str = ..., zero: float = ...): ...
    def rotate_bond(self, bond: BT, moving_atom: AT, angle: float, unit: str = ...) -> None: ...
    def resize_bond(self, bond: BT, moving_atom: AT, length: float, unit: str = ...) -> None: ...
    def closest_atom(self, point: Union[AT, Vector], unit: str = ...) -> AT: ...
    def distance_to_point(self, point: Vector, unit: str = ..., result_unit: str = ...) -> float: ...
    @overload
    def distance_to_mol(self, other: Molecule, result_unit: str = ..., return_atoms: Literal[False] = ...) -> float: ...
    @overload
    def distance_to_mol(self, other: Molecule, result_unit: str = ..., return_atoms: Literal[True] = ...) -> Tuple[float, AT, AT]: ...
    def wrap(self, length: float, angle: float = ..., length_unit: str = ..., angle_unit: str = ...) -> None: ...
    def get_center_of_mass(self, unit: str = ...) -> Vector: ...
    def get_mass(self) -> float: ...
    @overload
    def get_formula(self, as_dict: Literal[False] = ...) -> str: ...
    @overload
    def get_formula(self, as_dict: Literal[True] = ...) -> Dict[str, int]: ...
    def apply_strain(self, strain: Union[np.ndarray, Sequence[float]], voigt_form: bool = ...) -> None: ...
    def perturb_atoms(self, max_displacement: float = ..., unit: str = ..., atoms: Optional[Iterable[AT]] = ...) -> None: ...
    def perturb_lattice(self, max_displacement: float = ..., unit: str = ..., ams_convention: bool = ...) -> None: ...
    def substitute(self, connector: Union[BT, Tuple[AT, AT]], ligand: Molecule, ligand_connector: Union[BT, Tuple[AT, AT]], bond_length: Optional[float] = ..., steps: int = ..., cost_func_mol: Optional[Callable[[Molecule, Molecule], float]] = ..., cost_func_array: Optional[Callable[[np.ndarray, np.ndarray], float]] = ...) -> None: ...
    def __len__(self) -> int: ...
    def __str__(self) -> str: ...
    def __iter__(self) -> Iterator[AT]: ...
    @overload
    def __getitem__(self, key: SupportsIndex) -> AT: ...
    @overload
    def __getitem__(self, key: Tuple[SupportsIndex, SupportsIndex]) -> BT: ...
    def __add__(self, other: Molecule) -> Molecule: ...
    def __iadd__(self, other: Molecule) -> Molecule: ...
    def __copy__(self) -> Molecule: ...
    def __round__(self, ndigits: Optional[int] = ...) -> Molecule: ...
    def as_dict(self) -> MolDict: ...
    @classmethod
    def from_dict(cls, dictionary: MolDict) -> Molecule: ...
    @classmethod
    def from_elements(cls, elements: Iterable[str]) -> Molecule: ...
    def as_array(self, atom_subset: Optional[Iterable[AT]] = ...) -> np.ndarray: ...
    def from_array(self, xyz_array: Union[Molecule, Iterable[Tuple[float, float, float]]], atom_subset: Optional[Iterable[Atom]] = ...) -> None: ...
    def __array__(self, dtype: Union[None, type, np.dtype] = ...) -> np.ndarray: ...
    def readxyz(self, f: TextIO, geometry: int = ..., **other: Any) -> None: ...
    def writexyz(self, f: TextIO, **other: Any) -> None: ...
    def readmol(self, f: TextIO, **other: Any) -> None: ...
    def writemol(self, f: TextIO, **other: Any) -> None: ...
    def readmol2(self, f: TextIO, **other: Any) -> None: ...
    def writemol2(self, f: TextIO, **other: Any) -> None: ...
    def readpdb(self, f: TextIO, geometry: int = ..., **other: Any) -> PDBHandler: ...
    def writepdb(self, f: TextIO, **other: Any) -> None: ...
    def read(self, filename: Union[str, PathLike], inputformat: Optional[str] = ..., **other: Any) -> Optional[PDBHandler]: ...
    def write(self, filename: Union[str, PathLike], outputformat: Optional[str] = ..., **other: Any) -> None: ...
    _readformat: Dict[str, Callable[..., None]]
    _writeformat: Dict[str, Callable[..., None]]
